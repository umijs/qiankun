{"version":3,"names":["_core","require","helper","template","statement","helperIDs","WeakMap","addCreateSuperHelper","file","has","t","cloneNode","clone","get","addHelper","_unused","id","scope","generateUidIdentifier","set","fn","CREATE_SUPER","GET_PROTOTYPE_OF","POSSIBLE_CONSTRUCTOR_RETURN","path","unshiftContainer","registerDeclaration"],"sources":["../src/inline-createSuper-helpers.ts"],"sourcesContent":["import { template, types as t, type File } from \"@babel/core\";\n\nconst helper = template.statement`\n  function CREATE_SUPER(Derived) {\n    function isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n\n      // core-js@3\n      if (Reflect.construct.sham) return false;\n\n      // Proxy can't be polyfilled. Every browser implemented\n      // proxies before or at the same time as Reflect.construct,\n      // so if they support Proxy they also support Reflect.construct.\n      if (typeof Proxy === \"function\") return true;\n\n      // Since Reflect.construct can't be properly polyfilled, some\n      // implementations (e.g. core-js@2) don't set the correct internal slots.\n      // Those polyfills don't allow us to subclass built-ins, so we need to\n      // use our fallback implementation.\n      try {\n        // If the internal slots aren't set, this throws an error similar to\n        //   TypeError: this is not a Date object.\n        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    return function () {\n      var Super = GET_PROTOTYPE_OF(Derived), result;\n      if (isNativeReflectConstruct()) {\n        // NOTE: This doesn't work if this.__proto__.constructor has been modified.\n        var NewTarget = GET_PROTOTYPE_OF(this).constructor;\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n      return POSSIBLE_CONSTRUCTOR_RETURN(this, result);\n    }\n  }\n`;\n\nconst helperIDs = new WeakMap();\n\nexport default function addCreateSuperHelper(file: File) {\n  if (helperIDs.has(file)) {\n    // TODO: Only use t.cloneNode in Babel 8\n    // t.cloneNode isn't supported in every version\n    return (t.cloneNode || t.clone)(helperIDs.get(file));\n  }\n\n  try {\n    return file.addHelper(\"createSuper\");\n  } catch {\n    // Babel <7.9.0 doesn't support the helper.\n  }\n\n  const id = file.scope.generateUidIdentifier(\"createSuper\");\n  helperIDs.set(file, id);\n\n  const fn = helper({\n    CREATE_SUPER: id,\n    GET_PROTOTYPE_OF: file.addHelper(\"getPrototypeOf\"),\n    POSSIBLE_CONSTRUCTOR_RETURN: file.addHelper(\"possibleConstructorReturn\"),\n  });\n\n  file.path.unshiftContainer(\"body\", [fn]);\n  file.scope.registerDeclaration(file.path.get(\"body.0\"));\n\n  return t.cloneNode(id);\n}\n"],"mappings":";;;;;;AAAA,IAAAA,KAAA,GAAAC,OAAA;AAEA,MAAMC,MAAM,GAAGC,cAAQ,CAACC,SAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAED,MAAMC,SAAS,GAAG,IAAIC,OAAO,CAAC,CAAC;AAEhB,SAASC,oBAAoBA,CAACC,IAAU,EAAE;EACvD,IAAIH,SAAS,CAACI,GAAG,CAACD,IAAI,CAAC,EAAE;IAGvB,OAAO,CAACE,WAAC,CAACC,SAAS,IAAID,WAAC,CAACE,KAAK,EAAEP,SAAS,CAACQ,GAAG,CAACL,IAAI,CAAC,CAAC;EACtD;EAEA,IAAI;IACF,OAAOA,IAAI,CAACM,SAAS,CAAC,aAAa,CAAC;EACtC,CAAC,CAAC,OAAAC,OAAA,EAAM,CAER;EAEA,MAAMC,EAAE,GAAGR,IAAI,CAACS,KAAK,CAACC,qBAAqB,CAAC,aAAa,CAAC;EAC1Db,SAAS,CAACc,GAAG,CAACX,IAAI,EAAEQ,EAAE,CAAC;EAEvB,MAAMI,EAAE,GAAGlB,MAAM,CAAC;IAChBmB,YAAY,EAAEL,EAAE;IAChBM,gBAAgB,EAAEd,IAAI,CAACM,SAAS,CAAC,gBAAgB,CAAC;IAClDS,2BAA2B,EAAEf,IAAI,CAACM,SAAS,CAAC,2BAA2B;EACzE,CAAC,CAAC;EAEFN,IAAI,CAACgB,IAAI,CAACC,gBAAgB,CAAC,MAAM,EAAE,CAACL,EAAE,CAAC,CAAC;EACxCZ,IAAI,CAACS,KAAK,CAACS,mBAAmB,CAAClB,IAAI,CAACgB,IAAI,CAACX,GAAG,CAAC,QAAQ,CAAC,CAAC;EAEvD,OAAOH,WAAC,CAACC,SAAS,CAACK,EAAE,CAAC;AACxB"}