{"version":3,"file":"Text.js","sourceRoot":"","sources":["../src/Text.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;;;;;AAE3D,uCAAyB;AAEzB;;;GAGG;AACH,IAAY,QAEX;AAFD,WAAY,QAAQ;IAClB,yBAAa,CAAA;AACf,CAAC,EAFW,QAAQ,GAAR,gBAAQ,KAAR,gBAAQ,QAEnB;AAED;;;GAGG;AACH,IAAY,WAkBX;AAlBD,WAAY,WAAW;IACrB;;OAEG;IACH,4BAAa,CAAA;IAEb;;;;;OAKG;IACH,wBAAS,CAAA;IAET;;OAEG;IACH,+BAAgB,CAAA;AAClB,CAAC,EAlBW,WAAW,GAAX,mBAAW,KAAX,mBAAW,QAkBtB;AAED;;;;;;;;GAQG;AACH,MAAa,IAAI;IAIf;;;;;;OAMG;IACI,MAAM,CAAC,UAAU,CAAC,KAAa,EAAE,WAAmB,EAAE,YAAoB;QAC/E,OAAO,KAAK,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;IACrD,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,aAAa,CAAC,KAAa;QACvC,OAAO,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,EAAE,MAAM,CAAC,CAAC;IACnD,CAAC;IAED;;;;OAIG;IACI,MAAM,CAAC,WAAW,CAAC,KAAa;QACrC,OAAO,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,EAAE,IAAI,CAAC,CAAC;IACjD,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,SAAS,CAAC,KAAa,EAAE,WAAwB;QAC7D,OAAO,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,EAAE,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC,CAAC;IACzE,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,UAAU,CAAC,WAAwB;QAC/C,QAAQ,WAAW,EAAE;YACnB,KAAK,WAAW,CAAC,IAAI;gBACnB,OAAO,MAAM,CAAC;YAChB,KAAK,WAAW,CAAC,EAAE;gBACjB,OAAO,IAAI,CAAC;YACd,KAAK,WAAW,CAAC,SAAS;gBACxB,OAAO,EAAE,CAAC,GAAG,CAAC;YAChB;gBACE,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC;SAC/C;IACH,CAAC;IAED;;;;;OAKG;IACI,MAAM,CAAC,MAAM,CAAC,CAAS,EAAE,aAAqB,EAAE,mBAA2B,GAAG;QACnF,IAAI,gBAAgB,CAAC,MAAM,KAAK,CAAC,EAAE;YACjC,MAAM,IAAI,KAAK,CAAC,4DAA4D,CAAC,CAAC;SAC/E;QAED,IAAI,CAAC,CAAC,MAAM,GAAG,aAAa,EAAE;YAC5B,MAAM,YAAY,GAAa,IAAI,KAAK,CAAC,aAAa,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC;YACnE,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YACxB,OAAO,YAAY,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;SAC5C;aAAM;YACL,OAAO,CAAC,CAAC;SACV;IACH,CAAC;IAED;;;;;OAKG;IACI,MAAM,CAAC,QAAQ,CAAC,CAAS,EAAE,aAAqB,EAAE,mBAA2B,GAAG;QACrF,IAAI,gBAAgB,CAAC,MAAM,KAAK,CAAC,EAAE;YACjC,MAAM,IAAI,KAAK,CAAC,4DAA4D,CAAC,CAAC;SAC/E;QAED,IAAI,CAAC,CAAC,MAAM,GAAG,aAAa,EAAE;YAC5B,MAAM,YAAY,GAAa,IAAI,KAAK,CAAC,aAAa,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC;YACnE,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACrB,OAAO,YAAY,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;SAC5C;aAAM;YACL,OAAO,CAAC,CAAC;SACV;IACH,CAAC;IAED;;;;;;OAMG;IACI,MAAM,CAAC,oBAAoB,CAAC,CAAS,EAAE,aAAqB;QACjE,IAAI,aAAa,GAAG,CAAC,EAAE;YACrB,MAAM,IAAI,KAAK,CAAC,+CAA+C,CAAC,CAAC;SAClE;QAED,IAAI,CAAC,CAAC,MAAM,IAAI,aAAa,EAAE;YAC7B,OAAO,CAAC,CAAC;SACV;QAED,IAAI,CAAC,CAAC,MAAM,IAAI,CAAC,EAAE;YACjB,OAAO,CAAC,CAAC,SAAS,CAAC,CAAC,EAAE,aAAa,CAAC,CAAC;SACtC;QAED,OAAO,CAAC,CAAC,SAAS,CAAC,CAAC,EAAE,aAAa,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC;IACnD,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,qBAAqB,CAAC,CAAS,EAAE,cAA2B,WAAW,CAAC,EAAE;QACtF,8BAA8B;QAC9B,IAAI,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE;YACnC,OAAO,CAAC,CAAC,CAAC,iBAAiB;SAC5B;QACD,OAAO,CAAC,GAAG,WAAW,CAAC,CAAC,aAAa;IACvC,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,YAAY,CAAC,OAAe;QACxC,OAAO,OAAO,CAAC,OAAO,CAAC,gBAAgB,EAAE,MAAM,CAAC,CAAC;IACnD,CAAC;;AApIuB,kBAAa,GAAW,kBAAkB,CAAC;AAC3C,uBAAkB,GAAW,oBAAoB,CAAC;AAF/D,oBAAI","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as os from 'os';\n\n/**\n * The allowed types of encodings, as supported by Node.js\n * @public\n */\nexport enum Encoding {\n  Utf8 = 'utf8'\n}\n\n/**\n * Enumeration controlling conversion of newline characters.\n * @public\n */\nexport enum NewlineKind {\n  /**\n   * Windows-style newlines\n   */\n  CrLf = '\\r\\n',\n\n  /**\n   * POSIX-style newlines\n   *\n   * @remarks\n   * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.\n   */\n  Lf = '\\n',\n\n  /**\n   * Default newline type for this operating system (`os.EOL`).\n   */\n  OsDefault = 'os'\n}\n\n/**\n * Operations for working with strings that contain text.\n *\n * @remarks\n * The utilities provided by this class are intended to be simple, small, and very\n * broadly applicable.\n *\n * @public\n */\nexport class Text {\n  private static readonly _newLineRegEx: RegExp = /\\r\\n|\\n\\r|\\r|\\n/g;\n  private static readonly _newLineAtEndRegEx: RegExp = /(\\r\\n|\\n\\r|\\r|\\n)$/;\n\n  /**\n   * Returns the same thing as targetString.replace(searchValue, replaceValue), except that\n   * all matches are replaced, rather than just the first match.\n   * @param input         - The string to be modified\n   * @param searchValue   - The value to search for\n   * @param replaceValue  - The replacement text\n   */\n  public static replaceAll(input: string, searchValue: string, replaceValue: string): string {\n    return input.split(searchValue).join(replaceValue);\n  }\n\n  /**\n   * Converts all newlines in the provided string to use Windows-style CRLF end of line characters.\n   */\n  public static convertToCrLf(input: string): string {\n    return input.replace(Text._newLineRegEx, '\\r\\n');\n  }\n\n  /**\n   * Converts all newlines in the provided string to use POSIX-style LF end of line characters.\n   *\n   * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.\n   */\n  public static convertToLf(input: string): string {\n    return input.replace(Text._newLineRegEx, '\\n');\n  }\n\n  /**\n   * Converts all newlines in the provided string to use the specified newline type.\n   */\n  public static convertTo(input: string, newlineKind: NewlineKind): string {\n    return input.replace(Text._newLineRegEx, Text.getNewline(newlineKind));\n  }\n\n  /**\n   * Returns the newline character sequence for the specified `NewlineKind`.\n   */\n  public static getNewline(newlineKind: NewlineKind): string {\n    switch (newlineKind) {\n      case NewlineKind.CrLf:\n        return '\\r\\n';\n      case NewlineKind.Lf:\n        return '\\n';\n      case NewlineKind.OsDefault:\n        return os.EOL;\n      default:\n        throw new Error('Unsupported newline kind');\n    }\n  }\n\n  /**\n   * Append characters to the end of a string to ensure the result has a minimum length.\n   * @remarks\n   * If the string length already exceeds the minimum length, then the string is unchanged.\n   * The string is not truncated.\n   */\n  public static padEnd(s: string, minimumLength: number, paddingCharacter: string = ' '): string {\n    if (paddingCharacter.length !== 1) {\n      throw new Error('The paddingCharacter parameter must be a single character.');\n    }\n\n    if (s.length < minimumLength) {\n      const paddingArray: string[] = new Array(minimumLength - s.length);\n      paddingArray.unshift(s);\n      return paddingArray.join(paddingCharacter);\n    } else {\n      return s;\n    }\n  }\n\n  /**\n   * Append characters to the start of a string to ensure the result has a minimum length.\n   * @remarks\n   * If the string length already exceeds the minimum length, then the string is unchanged.\n   * The string is not truncated.\n   */\n  public static padStart(s: string, minimumLength: number, paddingCharacter: string = ' '): string {\n    if (paddingCharacter.length !== 1) {\n      throw new Error('The paddingCharacter parameter must be a single character.');\n    }\n\n    if (s.length < minimumLength) {\n      const paddingArray: string[] = new Array(minimumLength - s.length);\n      paddingArray.push(s);\n      return paddingArray.join(paddingCharacter);\n    } else {\n      return s;\n    }\n  }\n\n  /**\n   * If the string is longer than maximumLength characters, truncate it to that length\n   * using \"...\" to indicate the truncation.\n   *\n   * @remarks\n   * For example truncateWithEllipsis('1234578', 5) would produce '12...'.\n   */\n  public static truncateWithEllipsis(s: string, maximumLength: number): string {\n    if (maximumLength < 0) {\n      throw new Error('The maximumLength cannot be a negative number');\n    }\n\n    if (s.length <= maximumLength) {\n      return s;\n    }\n\n    if (s.length <= 3) {\n      return s.substring(0, maximumLength);\n    }\n\n    return s.substring(0, maximumLength - 3) + '...';\n  }\n\n  /**\n   * Returns the input string with a trailing `\\n` character appended, if not already present.\n   */\n  public static ensureTrailingNewline(s: string, newlineKind: NewlineKind = NewlineKind.Lf): string {\n    // Is there already a newline?\n    if (Text._newLineAtEndRegEx.test(s)) {\n      return s; // yes, no change\n    }\n    return s + newlineKind; // no, add it\n  }\n\n  /**\n   * Escapes a string so that it can be treated as a literal string when used in a regular expression.\n   */\n  public static escapeRegExp(literal: string): string {\n    return literal.replace(/[^A-Za-z0-9_]/g, '\\\\$&');\n  }\n}\n"]}