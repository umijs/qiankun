{"version":3,"file":"Collector.js","sourceRoot":"","sources":["../../src/collector/Collector.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as ts from 'typescript';\nimport * as tsdoc from '@microsoft/tsdoc';\nimport { PackageJsonLookup, Sort, InternalError } from '@rushstack/node-core-library';\nimport { ReleaseTag } from '@microsoft/api-extractor-model';\n\nimport { ExtractorMessageId } from '../api/ExtractorMessageId';\n\nimport { CollectorEntity } from './CollectorEntity';\nimport { AstSymbolTable } from '../analyzer/AstSymbolTable';\nimport { AstEntity } from '../analyzer/AstEntity';\nimport { AstModule, AstModuleExportInfo } from '../analyzer/AstModule';\nimport { AstSymbol } from '../analyzer/AstSymbol';\nimport { AstDeclaration } from '../analyzer/AstDeclaration';\nimport { TypeScriptHelpers } from '../analyzer/TypeScriptHelpers';\nimport { WorkingPackage } from './WorkingPackage';\nimport { PackageDocComment } from '../aedoc/PackageDocComment';\nimport { DeclarationMetadata, InternalDeclarationMetadata } from './DeclarationMetadata';\nimport { ApiItemMetadata, IApiItemMetadataOptions } from './ApiItemMetadata';\nimport { SymbolMetadata } from './SymbolMetadata';\nimport { TypeScriptInternals, IGlobalVariableAnalyzer } from '../analyzer/TypeScriptInternals';\nimport { MessageRouter } from './MessageRouter';\nimport { AstReferenceResolver } from '../analyzer/AstReferenceResolver';\nimport { ExtractorConfig } from '../api/ExtractorConfig';\nimport { AstNamespaceImport } from '../analyzer/AstNamespaceImport';\nimport { AstImport } from '../analyzer/AstImport';\nimport { SourceMapper } from './SourceMapper';\n\n/**\n * Options for Collector constructor.\n */\nexport interface ICollectorOptions {\n  /**\n   * Configuration for the TypeScript compiler.  The most important options to set are:\n   *\n   * - target: ts.ScriptTarget.ES5\n   * - module: ts.ModuleKind.CommonJS\n   * - moduleResolution: ts.ModuleResolutionKind.NodeJs\n   * - rootDir: inputFolder\n   */\n  program: ts.Program;\n\n  messageRouter: MessageRouter;\n\n  extractorConfig: ExtractorConfig;\n\n  sourceMapper: SourceMapper;\n}\n\n/**\n * The `Collector` manages the overall data set that is used by `ApiModelGenerator`,\n * `DtsRollupGenerator`, and `ApiReportGenerator`.  Starting from the working package's entry point,\n * the `Collector` collects all exported symbols, determines how to import any symbols they reference,\n * assigns unique names, and sorts everything into a normalized alphabetical ordering.\n */\nexport class Collector {\n  public readonly program: ts.Program;\n  public readonly typeChecker: ts.TypeChecker;\n  public readonly globalVariableAnalyzer: IGlobalVariableAnalyzer;\n  public readonly astSymbolTable: AstSymbolTable;\n  public readonly astReferenceResolver: AstReferenceResolver;\n\n  public readonly packageJsonLookup: PackageJsonLookup;\n  public readonly messageRouter: MessageRouter;\n\n  public readonly workingPackage: WorkingPackage;\n\n  public readonly extractorConfig: ExtractorConfig;\n\n  public readonly sourceMapper: SourceMapper;\n\n  /**\n   * The `ExtractorConfig.bundledPackages` names in a set.\n   */\n  public readonly bundledPackageNames: ReadonlySet<string>;\n\n  private readonly _program: ts.Program;\n\n  private readonly _tsdocParser: tsdoc.TSDocParser;\n\n  private _astEntryPoint: AstModule | undefined;\n\n  private readonly _entities: CollectorEntity[] = [];\n  private readonly _entitiesByAstEntity: Map<AstEntity, CollectorEntity> = new Map<\n    AstEntity,\n    CollectorEntity\n  >();\n  private readonly _entitiesBySymbol: Map<ts.Symbol, CollectorEntity> = new Map<ts.Symbol, CollectorEntity>();\n\n  private readonly _starExportedExternalModulePaths: string[] = [];\n\n  private readonly _dtsTypeReferenceDirectives: Set<string> = new Set<string>();\n  private readonly _dtsLibReferenceDirectives: Set<string> = new Set<string>();\n\n  // Used by getOverloadIndex()\n  private readonly _cachedOverloadIndexesByDeclaration: Map<AstDeclaration, number>;\n\n  public constructor(options: ICollectorOptions) {\n    this.packageJsonLookup = new PackageJsonLookup();\n\n    this._program = options.program;\n    this.extractorConfig = options.extractorConfig;\n    this.sourceMapper = options.sourceMapper;\n\n    const entryPointSourceFile: ts.SourceFile | undefined = options.program.getSourceFile(\n      this.extractorConfig.mainEntryPointFilePath\n    );\n\n    if (!entryPointSourceFile) {\n      throw new Error('Unable to load file: ' + this.extractorConfig.mainEntryPointFilePath);\n    }\n\n    if (!this.extractorConfig.packageFolder || !this.extractorConfig.packageJson) {\n      // TODO: We should be able to analyze projects that don't have any package.json.\n      // The ExtractorConfig class is already designed to allow this.\n      throw new Error('Unable to find a package.json file for the project being analyzed');\n    }\n\n    this.workingPackage = new WorkingPackage({\n      packageFolder: this.extractorConfig.packageFolder,\n      packageJson: this.extractorConfig.packageJson,\n      entryPointSourceFile\n    });\n\n    this.messageRouter = options.messageRouter;\n\n    this.program = options.program;\n    this.typeChecker = options.program.getTypeChecker();\n    this.globalVariableAnalyzer = TypeScriptInternals.getGlobalVariableAnalyzer(this.program);\n\n    this._tsdocParser = new tsdoc.TSDocParser(this.extractorConfig.tsdocConfiguration);\n\n    this.bundledPackageNames = new Set<string>(this.extractorConfig.bundledPackages);\n\n    this.astSymbolTable = new AstSymbolTable(\n      this.program,\n      this.typeChecker,\n      this.packageJsonLookup,\n      this.bundledPackageNames,\n      this.messageRouter\n    );\n    this.astReferenceResolver = new AstReferenceResolver(this);\n\n    this._cachedOverloadIndexesByDeclaration = new Map<AstDeclaration, number>();\n  }\n\n  /**\n   * Returns a list of names (e.g. \"example-library\") that should appear in a reference like this:\n   *\n   * ```\n   * /// <reference types=\"example-library\" />\n   * ```\n   */\n  public get dtsTypeReferenceDirectives(): ReadonlySet<string> {\n    return this._dtsTypeReferenceDirectives;\n  }\n\n  /**\n   * A list of names (e.g. \"runtime-library\") that should appear in a reference like this:\n   *\n   * ```\n   * /// <reference lib=\"runtime-library\" />\n   * ```\n   */\n  public get dtsLibReferenceDirectives(): ReadonlySet<string> {\n    return this._dtsLibReferenceDirectives;\n  }\n\n  public get entities(): ReadonlyArray<CollectorEntity> {\n    return this._entities;\n  }\n\n  /**\n   * A list of module specifiers (e.g. `\"@rushstack/node-core-library/lib/FileSystem\"`) that should be emitted\n   * as star exports (e.g. `export * from \"@rushstack/node-core-library/lib/FileSystem\"`).\n   */\n  public get starExportedExternalModulePaths(): ReadonlyArray<string> {\n    return this._starExportedExternalModulePaths;\n  }\n\n  /**\n   * Perform the analysis.\n   */\n  public analyze(): void {\n    if (this._astEntryPoint) {\n      throw new Error('DtsRollupGenerator.analyze() was already called');\n    }\n\n    // This runs a full type analysis, and then augments the Abstract Syntax Tree (i.e. declarations)\n    // with semantic information (i.e. symbols).  The \"diagnostics\" are a subset of the everyday\n    // compile errors that would result from a full compilation.\n    for (const diagnostic of this._program.getSemanticDiagnostics()) {\n      this.messageRouter.addCompilerDiagnostic(diagnostic);\n    }\n\n    const sourceFiles: readonly ts.SourceFile[] = this.program.getSourceFiles();\n\n    if (this.messageRouter.showDiagnostics) {\n      this.messageRouter.logDiagnosticHeader('Root filenames');\n      for (const fileName of this.program.getRootFileNames()) {\n        this.messageRouter.logDiagnostic(fileName);\n      }\n      this.messageRouter.logDiagnosticFooter();\n\n      this.messageRouter.logDiagnosticHeader('Files analyzed by compiler');\n      for (const sourceFile of sourceFiles) {\n        this.messageRouter.logDiagnostic(sourceFile.fileName);\n      }\n      this.messageRouter.logDiagnosticFooter();\n    }\n\n    // We can throw this error earlier in CompilerState.ts, but intentionally wait until after we've logged the\n    // associated diagnostic message above to make debugging easier for developers.\n    // Typically there will be many such files -- to avoid too much noise, only report the first one.\n    const badSourceFile: ts.SourceFile | undefined = sourceFiles.find(\n      ({ fileName }) => !ExtractorConfig.hasDtsFileExtension(fileName)\n    );\n    if (badSourceFile) {\n      this.messageRouter.addAnalyzerIssueForPosition(\n        ExtractorMessageId.WrongInputFileType,\n        'Incorrect file type; API Extractor expects to analyze compiler outputs with the .d.ts file extension. ' +\n          'Troubleshooting tips: https://api-extractor.com/link/dts-error',\n        badSourceFile,\n        0\n      );\n    }\n\n    // Build the entry point\n    const entryPointSourceFile: ts.SourceFile = this.workingPackage.entryPointSourceFile;\n\n    const astEntryPoint: AstModule =\n      this.astSymbolTable.fetchAstModuleFromWorkingPackage(entryPointSourceFile);\n    this._astEntryPoint = astEntryPoint;\n\n    const packageDocCommentTextRange: ts.TextRange | undefined = PackageDocComment.tryFindInSourceFile(\n      entryPointSourceFile,\n      this\n    );\n\n    if (packageDocCommentTextRange) {\n      const range: tsdoc.TextRange = tsdoc.TextRange.fromStringRange(\n        entryPointSourceFile.text,\n        packageDocCommentTextRange.pos,\n        packageDocCommentTextRange.end\n      );\n\n      this.workingPackage.tsdocParserContext = this._tsdocParser.parseRange(range);\n\n      this.messageRouter.addTsdocMessages(this.workingPackage.tsdocParserContext, entryPointSourceFile);\n\n      this.workingPackage.tsdocComment = this.workingPackage.tsdocParserContext!.docComment;\n    }\n\n    const astModuleExportInfo: AstModuleExportInfo =\n      this.astSymbolTable.fetchAstModuleExportInfo(astEntryPoint);\n\n    // Create a CollectorEntity for each top-level export.\n    const processedAstEntities: AstEntity[] = [];\n    for (const [exportName, astEntity] of astModuleExportInfo.exportedLocalEntities) {\n      this._createCollectorEntity(astEntity, exportName);\n      processedAstEntities.push(astEntity);\n    }\n\n    // Recursively create the remaining CollectorEntities after the top-level entities\n    // have been processed.\n    const alreadySeenAstEntities: Set<AstEntity> = new Set<AstEntity>();\n    for (const astEntity of processedAstEntities) {\n      this._recursivelyCreateEntities(astEntity, alreadySeenAstEntities);\n      if (astEntity instanceof AstSymbol) {\n        this.fetchSymbolMetadata(astEntity);\n      }\n    }\n\n    this._makeUniqueNames();\n\n    for (const starExportedExternalModule of astModuleExportInfo.starExportedExternalModules) {\n      if (starExportedExternalModule.externalModulePath !== undefined) {\n        this._starExportedExternalModulePaths.push(starExportedExternalModule.externalModulePath);\n      }\n    }\n\n    Sort.sortBy(this._entities, (x) => x.getSortKey());\n    Sort.sortSet(this._dtsTypeReferenceDirectives);\n    Sort.sortSet(this._dtsLibReferenceDirectives);\n    this._starExportedExternalModulePaths.sort();\n  }\n\n  /**\n   * For a given ts.Identifier that is part of an AstSymbol that we analyzed, return the CollectorEntity that\n   * it refers to.  Returns undefined if it doesn't refer to anything interesting.\n   * @remarks\n   * Throws an Error if the ts.Identifier is not part of node tree that was analyzed.\n   */\n  public tryGetEntityForNode(identifier: ts.Identifier | ts.ImportTypeNode): CollectorEntity | undefined {\n    const astEntity: AstEntity | undefined = this.astSymbolTable.tryGetEntityForNode(identifier);\n    if (astEntity) {\n      return this._entitiesByAstEntity.get(astEntity);\n    }\n    return undefined;\n  }\n\n  /**\n   * For a given analyzed ts.Symbol, return the CollectorEntity that it refers to. Returns undefined if it\n   * doesn't refer to anything interesting.\n   */\n  public tryGetEntityForSymbol(symbol: ts.Symbol): CollectorEntity | undefined {\n    return this._entitiesBySymbol.get(symbol);\n  }\n\n  /**\n   * Returns the associated `CollectorEntity` for the given `astEntity`, if one was created during analysis.\n   */\n  public tryGetCollectorEntity(astEntity: AstEntity): CollectorEntity | undefined {\n    return this._entitiesByAstEntity.get(astEntity);\n  }\n\n  public fetchSymbolMetadata(astSymbol: AstSymbol): SymbolMetadata {\n    if (astSymbol.symbolMetadata === undefined) {\n      this._fetchSymbolMetadata(astSymbol);\n    }\n    return astSymbol.symbolMetadata as SymbolMetadata;\n  }\n\n  public fetchDeclarationMetadata(astDeclaration: AstDeclaration): DeclarationMetadata {\n    if (astDeclaration.declarationMetadata === undefined) {\n      // Fetching the SymbolMetadata always constructs the DeclarationMetadata\n      this._fetchSymbolMetadata(astDeclaration.astSymbol);\n    }\n    return astDeclaration.declarationMetadata as DeclarationMetadata;\n  }\n\n  public fetchApiItemMetadata(astDeclaration: AstDeclaration): ApiItemMetadata {\n    if (astDeclaration.apiItemMetadata === undefined) {\n      // Fetching the SymbolMetadata always constructs the ApiItemMetadata\n      this._fetchSymbolMetadata(astDeclaration.astSymbol);\n    }\n    return astDeclaration.apiItemMetadata as ApiItemMetadata;\n  }\n\n  public tryFetchMetadataForAstEntity(astEntity: AstEntity): SymbolMetadata | undefined {\n    if (astEntity instanceof AstSymbol) {\n      return this.fetchSymbolMetadata(astEntity);\n    }\n    if (astEntity instanceof AstImport) {\n      if (astEntity.astSymbol) {\n        return this.fetchSymbolMetadata(astEntity.astSymbol);\n      }\n    }\n    return undefined;\n  }\n\n  public isAncillaryDeclaration(astDeclaration: AstDeclaration): boolean {\n    const declarationMetadata: DeclarationMetadata = this.fetchDeclarationMetadata(astDeclaration);\n    return declarationMetadata.isAncillary;\n  }\n\n  public getNonAncillaryDeclarations(astSymbol: AstSymbol): ReadonlyArray<AstDeclaration> {\n    const result: AstDeclaration[] = [];\n    for (const astDeclaration of astSymbol.astDeclarations) {\n      const declarationMetadata: DeclarationMetadata = this.fetchDeclarationMetadata(astDeclaration);\n      if (!declarationMetadata.isAncillary) {\n        result.push(astDeclaration);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Removes the leading underscore, for example: \"_Example\" --> \"example*Example*_\"\n   *\n   * @remarks\n   * This causes internal definitions to sort alphabetically case-insensitive, then case-sensitive, and\n   * initially ignoring the underscore prefix, while still deterministically comparing it.\n   * The star is used as a delimiter because it is not a legal  identifier character.\n   */\n  public static getSortKeyIgnoringUnderscore(identifier: string | undefined): string {\n    if (!identifier) return '';\n\n    let parts: string[];\n\n    if (identifier[0] === '_') {\n      const withoutUnderscore: string = identifier.substr(1);\n      parts = [withoutUnderscore.toLowerCase(), '*', withoutUnderscore, '*', '_'];\n    } else {\n      parts = [identifier.toLowerCase(), '*', identifier];\n    }\n\n    return parts.join('');\n  }\n\n  /**\n   * For function-like signatures, this returns the TSDoc \"overload index\" which can be used to identify\n   * a specific overload.\n   */\n  public getOverloadIndex(astDeclaration: AstDeclaration): number {\n    const allDeclarations: ReadonlyArray<AstDeclaration> = astDeclaration.astSymbol.astDeclarations;\n    if (allDeclarations.length === 1) {\n      return 1; // trivial case\n    }\n\n    let overloadIndex: number | undefined = this._cachedOverloadIndexesByDeclaration.get(astDeclaration);\n\n    if (overloadIndex === undefined) {\n      // TSDoc index selectors are positive integers counting from 1\n      let nextIndex: number = 1;\n      for (const other of allDeclarations) {\n        // Filter out other declarations that are not overloads.  For example, an overloaded function can also\n        // be a namespace.\n        if (other.declaration.kind === astDeclaration.declaration.kind) {\n          this._cachedOverloadIndexesByDeclaration.set(other, nextIndex);\n          ++nextIndex;\n        }\n      }\n      overloadIndex = this._cachedOverloadIndexesByDeclaration.get(astDeclaration);\n    }\n\n    if (overloadIndex === undefined) {\n      // This should never happen\n      throw new InternalError('Error calculating overload index for declaration');\n    }\n\n    return overloadIndex;\n  }\n\n  private _createCollectorEntity(\n    astEntity: AstEntity,\n    exportName?: string,\n    parent?: CollectorEntity\n  ): CollectorEntity {\n    let entity: CollectorEntity | undefined = this._entitiesByAstEntity.get(astEntity);\n\n    if (!entity) {\n      entity = new CollectorEntity(astEntity);\n\n      this._entitiesByAstEntity.set(astEntity, entity);\n      if (astEntity instanceof AstSymbol) {\n        this._entitiesBySymbol.set(astEntity.followedSymbol, entity);\n      } else if (astEntity instanceof AstNamespaceImport) {\n        this._entitiesBySymbol.set(astEntity.symbol, entity);\n      }\n      this._entities.push(entity);\n      this._collectReferenceDirectives(astEntity);\n    }\n\n    if (exportName) {\n      if (parent) {\n        entity.addLocalExportName(exportName, parent);\n      } else {\n        entity.addExportName(exportName);\n      }\n    }\n\n    return entity;\n  }\n\n  private _recursivelyCreateEntities(astEntity: AstEntity, alreadySeenAstEntities: Set<AstEntity>): void {\n    if (alreadySeenAstEntities.has(astEntity)) return;\n    alreadySeenAstEntities.add(astEntity);\n\n    if (astEntity instanceof AstSymbol) {\n      astEntity.forEachDeclarationRecursive((astDeclaration: AstDeclaration) => {\n        for (const referencedAstEntity of astDeclaration.referencedAstEntities) {\n          if (referencedAstEntity instanceof AstSymbol) {\n            // We only create collector entities for root-level symbols. For example, if a symbol is\n            // nested inside a namespace, only the namespace gets a collector entity. Note that this\n            // is not true for AstNamespaceImports below.\n            if (referencedAstEntity.parentAstSymbol === undefined) {\n              this._createCollectorEntity(referencedAstEntity);\n            }\n          } else {\n            this._createCollectorEntity(referencedAstEntity);\n          }\n\n          this._recursivelyCreateEntities(referencedAstEntity, alreadySeenAstEntities);\n        }\n      });\n    }\n\n    if (astEntity instanceof AstNamespaceImport) {\n      const astModuleExportInfo: AstModuleExportInfo = astEntity.fetchAstModuleExportInfo(this);\n      const parentEntity: CollectorEntity | undefined = this._entitiesByAstEntity.get(astEntity);\n      if (!parentEntity) {\n        // This should never happen, as we've already created entities for all AstNamespaceImports.\n        throw new InternalError(\n          `Failed to get CollectorEntity for AstNamespaceImport with namespace name \"${astEntity.namespaceName}\"`\n        );\n      }\n\n      for (const [localExportName, localAstEntity] of astModuleExportInfo.exportedLocalEntities) {\n        // Create a CollectorEntity for each local export within an AstNamespaceImport entity.\n        this._createCollectorEntity(localAstEntity, localExportName, parentEntity);\n        this._recursivelyCreateEntities(localAstEntity, alreadySeenAstEntities);\n      }\n    }\n  }\n\n  /**\n   * Ensures a unique name for each item in the package typings file.\n   */\n  private _makeUniqueNames(): void {\n    // The following examples illustrate the nameForEmit heuristics:\n    //\n    // Example 1:\n    //   class X { } <--- nameForEmit should be \"A\" to simplify things and reduce possibility of conflicts\n    //   export { X as A };\n    //\n    // Example 2:\n    //   class X { } <--- nameForEmit should be \"X\" because choosing A or B would be nondeterministic\n    //   export { X as A };\n    //   export { X as B };\n    //\n    // Example 3:\n    //   class X { } <--- nameForEmit should be \"X_1\" because Y has a stronger claim to the name\n    //   export { X as A };\n    //   export { X as B };\n    //   class Y { } <--- nameForEmit should be \"X\"\n    //   export { Y as X };\n\n    // Set of names that should NOT be used when generating a unique nameForEmit\n    const usedNames: Set<string> = new Set<string>();\n\n    // First collect the names of explicit package exports, and perform a sanity check.\n    for (const entity of this._entities) {\n      for (const exportName of entity.exportNames) {\n        if (usedNames.has(exportName)) {\n          // This should be impossible\n          throw new InternalError(`A package cannot have two exports with the name \"${exportName}\"`);\n        }\n        usedNames.add(exportName);\n      }\n    }\n\n    // Ensure that each entity has a unique nameForEmit\n    for (const entity of this._entities) {\n      // What name would we ideally want to emit it as?\n      let idealNameForEmit: string;\n\n      // If this entity is exported exactly once, then we prefer the exported name\n      if (\n        entity.singleExportName !== undefined &&\n        entity.singleExportName !== ts.InternalSymbolName.Default\n      ) {\n        idealNameForEmit = entity.singleExportName;\n      } else {\n        // otherwise use the local name\n        idealNameForEmit = entity.astEntity.localName;\n      }\n\n      if (idealNameForEmit.includes('.')) {\n        // For an ImportType with a namespace chain, only the top namespace is imported.\n        idealNameForEmit = idealNameForEmit.split('.')[0];\n      }\n\n      // If the idealNameForEmit happens to be the same as one of the exports, then we're safe to use that...\n      if (entity.exportNames.has(idealNameForEmit)) {\n        // ...except that if it conflicts with a global name, then the global name wins\n        if (!this.globalVariableAnalyzer.hasGlobalName(idealNameForEmit)) {\n          // ...also avoid \"default\" which can interfere with \"export { default } from 'some-module;'\"\n          if (idealNameForEmit !== 'default') {\n            entity.nameForEmit = idealNameForEmit;\n            continue;\n          }\n        }\n      }\n\n      // Generate a unique name based on idealNameForEmit\n      let suffix: number = 1;\n      let nameForEmit: string = idealNameForEmit;\n\n      // Choose a name that doesn't conflict with usedNames or a global name\n      while (\n        nameForEmit === 'default' ||\n        usedNames.has(nameForEmit) ||\n        this.globalVariableAnalyzer.hasGlobalName(nameForEmit)\n      ) {\n        nameForEmit = `${idealNameForEmit}_${++suffix}`;\n      }\n      entity.nameForEmit = nameForEmit;\n      usedNames.add(nameForEmit);\n    }\n  }\n\n  private _fetchSymbolMetadata(astSymbol: AstSymbol): void {\n    if (astSymbol.symbolMetadata) {\n      return;\n    }\n\n    // When we solve an astSymbol, then we always also solve all of its parents and all of its declarations.\n    // The parent is solved first.\n    if (astSymbol.parentAstSymbol && astSymbol.parentAstSymbol.symbolMetadata === undefined) {\n      this._fetchSymbolMetadata(astSymbol.parentAstSymbol);\n    }\n\n    // Construct the DeclarationMetadata objects, and detect any ancillary declarations\n    this._calculateDeclarationMetadataForDeclarations(astSymbol);\n\n    // Calculate the ApiItemMetadata objects\n    for (const astDeclaration of astSymbol.astDeclarations) {\n      this._calculateApiItemMetadata(astDeclaration);\n    }\n\n    // The most public effectiveReleaseTag for all declarations\n    let maxEffectiveReleaseTag: ReleaseTag = ReleaseTag.None;\n\n    for (const astDeclaration of astSymbol.astDeclarations) {\n      // We know we solved this above\n      const apiItemMetadata: ApiItemMetadata = astDeclaration.apiItemMetadata as ApiItemMetadata;\n\n      const effectiveReleaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n\n      if (effectiveReleaseTag > maxEffectiveReleaseTag) {\n        maxEffectiveReleaseTag = effectiveReleaseTag;\n      }\n    }\n\n    // Update this last when we're sure no exceptions were thrown\n    astSymbol.symbolMetadata = new SymbolMetadata({\n      maxEffectiveReleaseTag\n    });\n  }\n\n  private _calculateDeclarationMetadataForDeclarations(astSymbol: AstSymbol): void {\n    // Initialize DeclarationMetadata for each declaration\n    for (const astDeclaration of astSymbol.astDeclarations) {\n      if (astDeclaration.declarationMetadata) {\n        throw new InternalError(\n          'AstDeclaration.declarationMetadata is not expected to have been initialized yet'\n        );\n      }\n\n      const metadata: InternalDeclarationMetadata = new InternalDeclarationMetadata();\n      metadata.tsdocParserContext = this._parseTsdocForAstDeclaration(astDeclaration);\n\n      astDeclaration.declarationMetadata = metadata;\n    }\n\n    // Detect ancillary declarations\n    for (const astDeclaration of astSymbol.astDeclarations) {\n      // For a getter/setter pair, make the setter ancillary to the getter\n      if (astDeclaration.declaration.kind === ts.SyntaxKind.SetAccessor) {\n        let foundGetter: boolean = false;\n        for (const getterAstDeclaration of astDeclaration.astSymbol.astDeclarations) {\n          if (getterAstDeclaration.declaration.kind === ts.SyntaxKind.GetAccessor) {\n            // Associate it with the getter\n            this._addAncillaryDeclaration(getterAstDeclaration, astDeclaration);\n\n            foundGetter = true;\n          }\n        }\n\n        if (!foundGetter) {\n          this.messageRouter.addAnalyzerIssue(\n            ExtractorMessageId.MissingGetter,\n            `The property \"${astDeclaration.astSymbol.localName}\" has a setter but no getter.`,\n            astDeclaration\n          );\n        }\n      }\n    }\n  }\n\n  private _addAncillaryDeclaration(\n    mainAstDeclaration: AstDeclaration,\n    ancillaryAstDeclaration: AstDeclaration\n  ): void {\n    const mainMetadata: InternalDeclarationMetadata =\n      mainAstDeclaration.declarationMetadata as InternalDeclarationMetadata;\n    const ancillaryMetadata: InternalDeclarationMetadata =\n      ancillaryAstDeclaration.declarationMetadata as InternalDeclarationMetadata;\n\n    if (mainMetadata.ancillaryDeclarations.indexOf(ancillaryAstDeclaration) >= 0) {\n      return; // already added\n    }\n\n    if (mainAstDeclaration.astSymbol !== ancillaryAstDeclaration.astSymbol) {\n      throw new InternalError(\n        'Invalid call to _addAncillaryDeclaration() because declarations do not' +\n          ' belong to the same symbol'\n      );\n    }\n\n    if (mainMetadata.isAncillary) {\n      throw new InternalError(\n        'Invalid call to _addAncillaryDeclaration() because the target is ancillary itself'\n      );\n    }\n\n    if (ancillaryMetadata.isAncillary) {\n      throw new InternalError(\n        'Invalid call to _addAncillaryDeclaration() because source is already ancillary' +\n          ' to another declaration'\n      );\n    }\n\n    if (mainAstDeclaration.apiItemMetadata || ancillaryAstDeclaration.apiItemMetadata) {\n      throw new InternalError(\n        'Invalid call to _addAncillaryDeclaration() because the API item metadata' +\n          ' has already been constructed'\n      );\n    }\n\n    ancillaryMetadata.isAncillary = true;\n    mainMetadata.ancillaryDeclarations.push(ancillaryAstDeclaration);\n  }\n\n  private _calculateApiItemMetadata(astDeclaration: AstDeclaration): void {\n    const declarationMetadata: InternalDeclarationMetadata =\n      astDeclaration.declarationMetadata as InternalDeclarationMetadata;\n    if (declarationMetadata.isAncillary) {\n      if (astDeclaration.declaration.kind === ts.SyntaxKind.SetAccessor) {\n        if (declarationMetadata.tsdocParserContext) {\n          this.messageRouter.addAnalyzerIssue(\n            ExtractorMessageId.SetterWithDocs,\n            `The doc comment for the property \"${astDeclaration.astSymbol.localName}\"` +\n              ` must appear on the getter, not the setter.`,\n            astDeclaration\n          );\n        }\n      }\n\n      // We never calculate ApiItemMetadata for an ancillary declaration; instead, it is assigned when\n      // the main declaration is processed.\n      return;\n    }\n\n    const options: IApiItemMetadataOptions = {\n      declaredReleaseTag: ReleaseTag.None,\n      effectiveReleaseTag: ReleaseTag.None,\n      isEventProperty: false,\n      isOverride: false,\n      isSealed: false,\n      isVirtual: false,\n      isPreapproved: false,\n      releaseTagSameAsParent: false\n    };\n\n    const parserContext: tsdoc.ParserContext | undefined = declarationMetadata.tsdocParserContext;\n    if (parserContext) {\n      const modifierTagSet: tsdoc.StandardModifierTagSet = parserContext.docComment.modifierTagSet;\n\n      let declaredReleaseTag: ReleaseTag = ReleaseTag.None;\n      let extraReleaseTags: boolean = false;\n\n      if (modifierTagSet.isPublic()) {\n        declaredReleaseTag = ReleaseTag.Public;\n      }\n      if (modifierTagSet.isBeta()) {\n        if (declaredReleaseTag !== ReleaseTag.None) {\n          extraReleaseTags = true;\n        } else {\n          declaredReleaseTag = ReleaseTag.Beta;\n        }\n      }\n      if (modifierTagSet.isAlpha()) {\n        if (declaredReleaseTag !== ReleaseTag.None) {\n          extraReleaseTags = true;\n        } else {\n          declaredReleaseTag = ReleaseTag.Alpha;\n        }\n      }\n      if (modifierTagSet.isInternal()) {\n        if (declaredReleaseTag !== ReleaseTag.None) {\n          extraReleaseTags = true;\n        } else {\n          declaredReleaseTag = ReleaseTag.Internal;\n        }\n      }\n\n      if (extraReleaseTags) {\n        if (!astDeclaration.astSymbol.isExternal) {\n          // for now, don't report errors for external code\n          this.messageRouter.addAnalyzerIssue(\n            ExtractorMessageId.ExtraReleaseTag,\n            'The doc comment should not contain more than one release tag',\n            astDeclaration\n          );\n        }\n      }\n\n      options.declaredReleaseTag = declaredReleaseTag;\n\n      options.isEventProperty = modifierTagSet.isEventProperty();\n      options.isOverride = modifierTagSet.isOverride();\n      options.isSealed = modifierTagSet.isSealed();\n      options.isVirtual = modifierTagSet.isVirtual();\n      const preapprovedTag: tsdoc.TSDocTagDefinition | void =\n        this.extractorConfig.tsdocConfiguration.tryGetTagDefinition('@preapproved');\n\n      if (preapprovedTag && modifierTagSet.hasTag(preapprovedTag)) {\n        // This feature only makes sense for potentially big declarations.\n        switch (astDeclaration.declaration.kind) {\n          case ts.SyntaxKind.ClassDeclaration:\n          case ts.SyntaxKind.EnumDeclaration:\n          case ts.SyntaxKind.InterfaceDeclaration:\n          case ts.SyntaxKind.ModuleDeclaration:\n            if (declaredReleaseTag === ReleaseTag.Internal) {\n              options.isPreapproved = true;\n            } else {\n              this.messageRouter.addAnalyzerIssue(\n                ExtractorMessageId.PreapprovedBadReleaseTag,\n                `The @preapproved tag cannot be applied to \"${astDeclaration.astSymbol.localName}\"` +\n                  ` without an @internal release tag`,\n                astDeclaration\n              );\n            }\n            break;\n          default:\n            this.messageRouter.addAnalyzerIssue(\n              ExtractorMessageId.PreapprovedUnsupportedType,\n              `The @preapproved tag cannot be applied to \"${astDeclaration.astSymbol.localName}\"` +\n                ` because it is not a supported declaration type`,\n              astDeclaration\n            );\n            break;\n        }\n      }\n    }\n\n    // This needs to be set regardless of whether or not a parserContext exists\n    if (astDeclaration.parent) {\n      const parentApiItemMetadata: ApiItemMetadata = this.fetchApiItemMetadata(astDeclaration.parent);\n      options.effectiveReleaseTag =\n        options.declaredReleaseTag === ReleaseTag.None\n          ? parentApiItemMetadata.effectiveReleaseTag\n          : options.declaredReleaseTag;\n\n      options.releaseTagSameAsParent =\n        parentApiItemMetadata.effectiveReleaseTag === options.effectiveReleaseTag;\n    } else {\n      options.effectiveReleaseTag = options.declaredReleaseTag;\n    }\n\n    if (options.effectiveReleaseTag === ReleaseTag.None) {\n      if (!astDeclaration.astSymbol.isExternal) {\n        // for now, don't report errors for external code\n        // Don't report missing release tags for forgotten exports (unless we're including forgotten exports\n        // in either the API report or doc model).\n        const astSymbol: AstSymbol = astDeclaration.astSymbol;\n        const entity: CollectorEntity | undefined = this._entitiesByAstEntity.get(astSymbol.rootAstSymbol);\n        if (\n          entity &&\n          (entity.consumable ||\n            this.extractorConfig.apiReportIncludeForgottenExports ||\n            this.extractorConfig.docModelIncludeForgottenExports)\n        ) {\n          // We also don't report errors for the default export of an entry point, since its doc comment\n          // isn't easy to obtain from the .d.ts file\n          if (astSymbol.rootAstSymbol.localName !== '_default') {\n            this.messageRouter.addAnalyzerIssue(\n              ExtractorMessageId.MissingReleaseTag,\n              `\"${entity.astEntity.localName}\" is part of the package's API, but it is missing ` +\n                `a release tag (@alpha, @beta, @public, or @internal)`,\n              astSymbol\n            );\n          }\n        }\n      }\n\n      options.effectiveReleaseTag = ReleaseTag.Public;\n    }\n\n    const apiItemMetadata: ApiItemMetadata = new ApiItemMetadata(options);\n    if (parserContext) {\n      apiItemMetadata.tsdocComment = parserContext.docComment;\n    }\n\n    astDeclaration.apiItemMetadata = apiItemMetadata;\n\n    // Lastly, share the result with any ancillary declarations\n    for (const ancillaryDeclaration of declarationMetadata.ancillaryDeclarations) {\n      ancillaryDeclaration.apiItemMetadata = apiItemMetadata;\n    }\n  }\n\n  private _parseTsdocForAstDeclaration(astDeclaration: AstDeclaration): tsdoc.ParserContext | undefined {\n    const declaration: ts.Declaration = astDeclaration.declaration;\n    let nodeForComment: ts.Node = declaration;\n\n    if (ts.isVariableDeclaration(declaration)) {\n      // Variable declarations are special because they can be combined into a list.  For example:\n      //\n      // /** A */ export /** B */ const /** C */ x = 1, /** D **/ [ /** E */ y, z] = [3, 4];\n      //\n      // The compiler will only emit comments A and C in the .d.ts file, so in general there isn't a well-defined\n      // way to document these parts.  API Extractor requires you to break them into separate exports like this:\n      //\n      // /** A */ export const x = 1;\n      //\n      // But _getReleaseTagForDeclaration() still receives a node corresponding to \"x\", so we need to walk upwards\n      // and find the containing statement in order for getJSDocCommentRanges() to read the comment that we expect.\n      const statement: ts.VariableStatement | undefined = TypeScriptHelpers.findFirstParent(\n        declaration,\n        ts.SyntaxKind.VariableStatement\n      ) as ts.VariableStatement | undefined;\n      if (statement !== undefined) {\n        // For a compound declaration, fall back to looking for C instead of A\n        if (statement.declarationList.declarations.length === 1) {\n          nodeForComment = statement;\n        }\n      }\n    }\n\n    const sourceFileText: string = declaration.getSourceFile().text;\n    const ranges: ts.CommentRange[] =\n      TypeScriptInternals.getJSDocCommentRanges(nodeForComment, sourceFileText) || [];\n\n    if (ranges.length === 0) {\n      return undefined;\n    }\n\n    // We use the JSDoc comment block that is closest to the definition, i.e.\n    // the last one preceding it\n    const range: ts.TextRange = ranges[ranges.length - 1];\n\n    const tsdocTextRange: tsdoc.TextRange = tsdoc.TextRange.fromStringRange(\n      sourceFileText,\n      range.pos,\n      range.end\n    );\n\n    const parserContext: tsdoc.ParserContext = this._tsdocParser.parseRange(tsdocTextRange);\n\n    this.messageRouter.addTsdocMessages(parserContext, declaration.getSourceFile(), astDeclaration);\n\n    // We delete the @privateRemarks block as early as possible, to ensure that it never leaks through\n    // into one of the output files.\n    parserContext.docComment.privateRemarks = undefined;\n\n    return parserContext;\n  }\n\n  private _collectReferenceDirectives(astEntity: AstEntity): void {\n    if (astEntity instanceof AstSymbol) {\n      const sourceFiles: ts.SourceFile[] = astEntity.astDeclarations.map((astDeclaration) =>\n        astDeclaration.declaration.getSourceFile()\n      );\n      return this._collectReferenceDirectivesFromSourceFiles(sourceFiles);\n    }\n\n    if (astEntity instanceof AstNamespaceImport) {\n      const sourceFiles: ts.SourceFile[] = [astEntity.astModule.sourceFile];\n      return this._collectReferenceDirectivesFromSourceFiles(sourceFiles);\n    }\n  }\n\n  private _collectReferenceDirectivesFromSourceFiles(sourceFiles: ts.SourceFile[]): void {\n    const seenFilenames: Set<string> = new Set<string>();\n\n    for (const sourceFile of sourceFiles) {\n      if (sourceFile && sourceFile.fileName) {\n        if (!seenFilenames.has(sourceFile.fileName)) {\n          seenFilenames.add(sourceFile.fileName);\n\n          for (const typeReferenceDirective of sourceFile.typeReferenceDirectives) {\n            const name: string = sourceFile.text.substring(\n              typeReferenceDirective.pos,\n              typeReferenceDirective.end\n            );\n            this._dtsTypeReferenceDirectives.add(name);\n          }\n\n          for (const libReferenceDirective of sourceFile.libReferenceDirectives) {\n            const name: string = sourceFile.text.substring(\n              libReferenceDirective.pos,\n              libReferenceDirective.end\n            );\n            this._dtsLibReferenceDirectives.add(name);\n          }\n        }\n      }\n    }\n  }\n}\n"]}