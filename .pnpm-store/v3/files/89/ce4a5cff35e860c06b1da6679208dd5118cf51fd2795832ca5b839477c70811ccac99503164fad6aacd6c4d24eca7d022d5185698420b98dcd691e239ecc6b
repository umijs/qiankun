{"version":3,"names":["_core","require","_helperSkipTransparentExpressionWrappers","_util","isSimpleMemberExpression","expression","skipTransparentExprWrapperNodes","t","isIdentifier","isSuper","isMemberExpression","computed","object","needsMemoize","path","optionalPath","scope","isOptionalMemberExpression","isOptionalCallExpression","node","childPath","skipTransparentExprWrappers","get","optional","isStatic","NULLISH_CHECK","template","NULLISH_CHECK_NO_DDA","NULLISH_CHECK_NEG","NULLISH_CHECK_NO_DDA_NEG","transformOptionalChain","pureGetters","noDocumentAll","replacementPath","ifNullish","wrapLast","isPattern","replaceWith","ast","optionals","push","type","length","checks","tmpVar","i","isCall","isCallExpression","chainWithTypes","callee","chain","ref","check","name","sequenceExpression","numericLiteral","generateUidIdentifierBasedOnNode","id","cloneNode","assignmentExpression","context","thisExpression","memoized","maybeGenerateMemoised","arguments","unshift","memberExpression","identifier","data","Object","defineProperty","enumerable","result","ifNullishBoolean","isBooleanLiteral","ifNullishFalse","value","tpl","logicalOp","map","reduce","expr","logicalExpression","conditionalExpression","transform","assumptions","maybeWrapped","findOutermostTransparentParent","parentPath","isUnaryExpression","operator","booleanLiteral","replacement","_baseRef","baseRef","callExpression","willPathCastToBoolean","buildUndefinedNode"],"sources":["../src/transform.ts"],"sourcesContent":["import { types as t, template } from \"@babel/core\";\nimport type { NodePath } from \"@babel/traverse\";\nimport {\n  skipTransparentExprWrapperNodes,\n  skipTransparentExprWrappers,\n} from \"@babel/helper-skip-transparent-expression-wrappers\";\nimport { willPathCastToBoolean, findOutermostTransparentParent } from \"./util\";\n\nfunction isSimpleMemberExpression(\n  expression: t.Expression | t.Super,\n): expression is t.Identifier | t.Super | t.MemberExpression {\n  expression = skipTransparentExprWrapperNodes(expression);\n  return (\n    t.isIdentifier(expression) ||\n    t.isSuper(expression) ||\n    (t.isMemberExpression(expression) &&\n      !expression.computed &&\n      isSimpleMemberExpression(expression.object))\n  );\n}\n\n/**\n * Test if a given optional chain `path` needs to be memoized\n * @param {NodePath} path\n * @returns {boolean}\n */\nfunction needsMemoize(\n  path: NodePath<t.OptionalCallExpression | t.OptionalMemberExpression>,\n) {\n  let optionalPath: NodePath = path;\n  const { scope } = path;\n  while (\n    optionalPath.isOptionalMemberExpression() ||\n    optionalPath.isOptionalCallExpression()\n  ) {\n    const { node } = optionalPath;\n    const childPath = skipTransparentExprWrappers(\n      // @ts-expect-error isOptionalMemberExpression does not work with NodePath union\n      optionalPath.isOptionalMemberExpression()\n        ? optionalPath.get(\"object\")\n        : optionalPath.get(\"callee\"),\n    );\n    if (node.optional) {\n      return !scope.isStatic(childPath.node);\n    }\n\n    optionalPath = childPath;\n  }\n}\n\nconst NULLISH_CHECK = template.expression(\n  `%%check%% === null || %%ref%% === void 0`,\n);\nconst NULLISH_CHECK_NO_DDA = template.expression(`%%check%% == null`);\nconst NULLISH_CHECK_NEG = template.expression(\n  `%%check%% !== null && %%ref%% !== void 0`,\n);\nconst NULLISH_CHECK_NO_DDA_NEG = template.expression(`%%check%% != null`);\n\ninterface OptionalChainAssumptions {\n  pureGetters: boolean;\n  noDocumentAll: boolean;\n}\n\nexport function transformOptionalChain(\n  path: NodePath<t.OptionalCallExpression | t.OptionalMemberExpression>,\n  { pureGetters, noDocumentAll }: OptionalChainAssumptions,\n  replacementPath: NodePath<t.Expression>,\n  ifNullish: t.Expression,\n  wrapLast?: (value: t.Expression) => t.Expression,\n) {\n  const { scope } = path;\n\n  // Replace `function (a, x = a.b?.c) {}` to `function (a, x = (() => a.b?.c)() ){}`\n  // so the temporary variable can be injected in correct scope\n  if (scope.path.isPattern() && needsMemoize(path)) {\n    replacementPath.replaceWith(\n      template.expression.ast`(() => ${replacementPath.node})()`,\n    );\n    // The injected optional chain will be queued and eventually transformed when visited\n    return;\n  }\n\n  const optionals = [];\n\n  let optionalPath = path;\n  while (\n    optionalPath.isOptionalMemberExpression() ||\n    optionalPath.isOptionalCallExpression()\n  ) {\n    const { node } = optionalPath;\n    if (node.optional) {\n      optionals.push(node);\n    }\n    // @ts-expect-error isOptionalMemberExpression does not work with NodePath union\n    if (optionalPath.isOptionalMemberExpression()) {\n      // @ts-expect-error todo(flow->ts) avoid changing more type\n      optionalPath.node.type = \"MemberExpression\";\n      // @ts-expect-error todo(flow->ts)\n      optionalPath = skipTransparentExprWrappers(optionalPath.get(\"object\"));\n    } else if (optionalPath.isOptionalCallExpression()) {\n      // @ts-expect-error todo(flow->ts) avoid changing more type\n      optionalPath.node.type = \"CallExpression\";\n      // @ts-expect-error todo(flow->ts)\n      optionalPath = skipTransparentExprWrappers(optionalPath.get(\"callee\"));\n    }\n  }\n\n  if (optionals.length === 0) {\n    // Malformed AST: there was an OptionalMemberExpression node\n    // with no actual optional elements.\n    return;\n  }\n\n  const checks = [];\n\n  let tmpVar;\n\n  for (let i = optionals.length - 1; i >= 0; i--) {\n    const node = optionals[i] as unknown as\n      | t.MemberExpression\n      | t.CallExpression;\n\n    const isCall = t.isCallExpression(node);\n\n    const chainWithTypes = isCall\n      ? // V8 intrinsics must not be an optional call\n        (node.callee as t.Expression)\n      : node.object;\n    const chain = skipTransparentExprWrapperNodes(chainWithTypes);\n\n    let ref;\n    let check;\n    if (isCall && t.isIdentifier(chain, { name: \"eval\" })) {\n      check = ref = chain;\n      // `eval?.()` is an indirect eval call transformed to `(0,eval)()`\n      node.callee = t.sequenceExpression([t.numericLiteral(0), ref]);\n    } else if (pureGetters && isCall && isSimpleMemberExpression(chain)) {\n      // If we assume getters are pure (avoiding a Function#call) and we are at the call,\n      // we can avoid a needless memoize. We only do this if the callee is a simple member\n      // expression, to avoid multiple calls to nested call expressions.\n      check = ref = node.callee;\n    } else if (scope.isStatic(chain)) {\n      check = ref = chainWithTypes;\n    } else {\n      // We cannot reuse the tmpVar for calls, because we need to\n      // store both the method and the receiver.\n      if (!tmpVar || isCall) {\n        tmpVar = scope.generateUidIdentifierBasedOnNode(chain);\n        scope.push({ id: t.cloneNode(tmpVar) });\n      }\n      ref = tmpVar;\n      check = t.assignmentExpression(\n        \"=\",\n        t.cloneNode(tmpVar),\n        // Here `chainWithTypes` MUST NOT be cloned because it could be\n        // updated when generating the memoised context of a call\n        // expression. It must be an Expression when `ref` is an identifier\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        chainWithTypes as t.Expression,\n      );\n\n      isCall ? (node.callee = ref) : (node.object = ref);\n    }\n\n    // Ensure call expressions have the proper `this`\n    // `foo.bar()` has context `foo`.\n    if (isCall && t.isMemberExpression(chain)) {\n      if (pureGetters && isSimpleMemberExpression(chain)) {\n        // To avoid a Function#call, we can instead re-grab the property from the context object.\n        // `a.?b.?()` translates roughly to `_a.b != null && _a.b()`\n        node.callee = chainWithTypes;\n      } else {\n        // Otherwise, we need to memoize the context object, and change the call into a Function#call.\n        // `a.?b.?()` translates roughly to `(_b = _a.b) != null && _b.call(_a)`\n        const { object } = chain;\n        let context: t.Expression;\n        if (t.isSuper(object)) {\n          context = t.thisExpression();\n        } else {\n          const memoized = scope.maybeGenerateMemoised(object);\n          if (memoized) {\n            context = memoized;\n            chain.object = t.assignmentExpression(\"=\", memoized, object);\n          } else {\n            context = object;\n          }\n        }\n\n        node.arguments.unshift(t.cloneNode(context));\n        // @ts-expect-error node.callee can not be an V8IntrinsicIdentifier: V8 intrinsic is disallowed in optional chain\n        node.callee = t.memberExpression(node.callee, t.identifier(\"call\"));\n      }\n    }\n\n    const data = { check: t.cloneNode(check), ref: t.cloneNode(ref) };\n    // We make `ref` non-enumerable, so that @babel/template doesn't throw\n    // in the noDocumentAll template if it's not used.\n    Object.defineProperty(data, \"ref\", { enumerable: false });\n    checks.push(data);\n  }\n\n  let result = replacementPath.node;\n  if (wrapLast) result = wrapLast(result);\n\n  const ifNullishBoolean = t.isBooleanLiteral(ifNullish);\n  const ifNullishFalse = ifNullishBoolean && ifNullish.value === false;\n\n  // prettier-ignore\n  const tpl = ifNullishFalse\n    ? (noDocumentAll ? NULLISH_CHECK_NO_DDA_NEG : NULLISH_CHECK_NEG)\n    : (noDocumentAll ? NULLISH_CHECK_NO_DDA : NULLISH_CHECK);\n  const logicalOp = ifNullishFalse ? \"&&\" : \"||\";\n\n  const check = checks\n    .map(tpl)\n    .reduce((expr, check) => t.logicalExpression(logicalOp, expr, check));\n\n  replacementPath.replaceWith(\n    ifNullishBoolean\n      ? t.logicalExpression(logicalOp, check, result)\n      : t.conditionalExpression(check, ifNullish, result),\n  );\n}\n\nexport function transform(\n  path: NodePath<t.OptionalCallExpression | t.OptionalMemberExpression>,\n  assumptions: OptionalChainAssumptions,\n) {\n  const { scope } = path;\n\n  // maybeWrapped points to the outermost transparent expression wrapper\n  // or the path itself\n  const maybeWrapped = findOutermostTransparentParent(path);\n  const { parentPath } = maybeWrapped;\n\n  if (parentPath.isUnaryExpression({ operator: \"delete\" })) {\n    transformOptionalChain(\n      path,\n      assumptions,\n      parentPath,\n      t.booleanLiteral(true),\n    );\n  } else {\n    let wrapLast;\n    if (\n      parentPath.isCallExpression({ callee: maybeWrapped.node }) &&\n      // note that the first condition must implies that `path.optional` is `true`,\n      // otherwise the parentPath should be an OptionalCallExpression\n      path.isOptionalMemberExpression()\n    ) {\n      // Ensure (a?.b)() has proper `this`\n      wrapLast = (replacement: t.MemberExpression) => {\n        // `(a?.b)()` to `(a == null ? undefined : a.b.bind(a))()`\n        // object must not be Super as super?.foo is invalid\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        const object = skipTransparentExprWrapperNodes(\n          replacement.object,\n        ) as t.Expression;\n        let baseRef: t.Expression;\n        if (!assumptions.pureGetters || !isSimpleMemberExpression(object)) {\n          // memoize the context object when getters are not always pure\n          // or the object is not a simple member expression\n          // `(a?.b.c)()` to `(a == null ? undefined : (_a$b = a.b).c.bind(_a$b))()`\n          baseRef = scope.maybeGenerateMemoised(object);\n          if (baseRef) {\n            replacement.object = t.assignmentExpression(\"=\", baseRef, object);\n          }\n        }\n        return t.callExpression(\n          t.memberExpression(replacement, t.identifier(\"bind\")),\n          [t.cloneNode(baseRef ?? object)],\n        );\n      };\n    }\n\n    transformOptionalChain(\n      path,\n      assumptions,\n      path,\n      willPathCastToBoolean(maybeWrapped)\n        ? t.booleanLiteral(false)\n        : scope.buildUndefinedNode(),\n      wrapLast,\n    );\n  }\n}\n"],"mappings":"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"}